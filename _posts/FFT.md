---
layout:	single
title: "FFT Argorithm"
date:	2020-05-13 22:57:34 +0900
categories: jekyll update
---

## FFT 알고리즘의 이해.

1.FFT 알고리즘의 동작방식.

이산 푸리에 변환(DFT)의 계산량을 줄이는 알고리즘.

푸리에 변환 : 임의의 입력 신호를 다양한 주파수를 갖는 주기함수들의 합으로 분해하여 표현하는 것.

DFT는 연산시 시간이 너무 오래 걸리기 때문에 실제 계산에서 나타나는 항의 주기성과 대칭성을 이용하여, 신호의 전부의 변환이 아닌, 필요한 신호만을 골라내어 최소화하며 고속으로 푸리에 변환을 연산한다. 예를 들어 총 8개의 DFT 신호가 있다 가정하면, 4개를 먼저 골라낸 후, 다시 4개의 신호를 단순히 연결함으로서 제외된 신호들의 예상치를 적용하게 되는 방법. 실제로 변환 시간의 분제로 인해, 실제적으로 거의 대부분 FFT를 사용하고 있으며, 빠르기는 DFT에 비해 최고 약 1000배의 시간차이를 보여준다고 한다.

고속 푸리에 변환의 핵심은 **분할과 정복**입니다. 즉, 복잡한 문제를 단순한 여러 개의 문제로 쪼개는 것입니다. 이산 푸리에 변환 행렬 FF는 전혀 성기지 않은 행렬입니다. 행렬의 모든 칸에 숫자가 들어차 있고, 그 숫자들마저도 그렇게 작지도 않습니다. 그렇기 때문에 어느 숫자 하나 무시할 수 없습니다. 그런데 이 행렬은 여러 개의 성긴 행렬들로 분해할 수 있습니다. 성긴 행렬이라는 것은 행렬의 원소들의 대부분이 0으로 채워져 있는 행렬입니다. 만약 FFT가 성긴 행렬 여러 개로 분해될 수 있다면, 정공법으로 뚫는 것보다 훨씬 적은 계산만으로도 원래의 목적을 달성할 수 있습니다.

2.Big O 표기법을 이용한 성능분석

DFT 알고리즘은 O(N^2)의  시간복잡도를 가지는데 반해, FFT 알고리즘은 O(NlogN)의 시간복잡도를 가진다.

-> DFT 알고리즘보다 더 빠른 계산시간을 가진다.

3.알고리즘의 코드 구현

도저히 코드 짜는 법을 모르겠어서 구글링으로 가져온 코드를 최대한 분석해봤습니다.

```
x와 y는 2^m 포인트의 실수와 허수 배열
dir = 1은 앞으로 변환을 제공
dir = -1은 역변환을 제공 
```

```
#define SWAP(x,y) {int temp = a; a=b;b=temp;}
typedef struct {
	double real, imag;
} COMPLEX;
void FFT(int dir, long m, complex <double> x[])
{
  long i, i1, i2,j, k, l, l1, l2, n;
  complex <double> tx, t1, u, c;
  /*포인트 수 계산*/
  n = 1;
  for(i = 0; i < m; i++) 
   n <<= 1;  
  /* 비트 반전 */
  i2 = n >> 1;
  j = 0;
  for (i = 0; i < n-1 ; i++)
  {
   if (i < j)
     swap(x[i], x[j]);
   k = i2;
   while (k <= j) 
   {
     j -= k;
     k >>= 1;
   }
   j += k;
  }
  /* FFT 계산 */
  c.real(-1.0);				//??
  c.imag(0.0);				//??
  l2 = 1;
  for (l = 0; l < m; l++) 
  {
   l1 = l2;
   l2 <<= 1;
   u.real(1.0);
   u.imag(0.0);
   for (j = 0; j < l1; j++) 
   {
     for (i = j; i < n; i += l2) 
     {
      i1 = i + l1;
      t1 = u * x[i1];
      x[i1] = x[i] - t1; 
      x[i] += t1;
     } 
     u = u * c;
   }
   c.imag(sqrt((1.0 - c.real()) / 2.0));
   if (dir == 1)
     c.imag(-c.imag());
   c.real(sqrt((1.0 + c.real()) / 2.0));
  }
  /* 정방향 변환을 위한 스케일링 */
  if (dir == 1) 
  {
   for (i = 0; i < n; i++)
     x[i] /= n;   
  }  
  return;
}
```

c 와 u 라는 구조체가 필요해 보이지만 어떻게 써야하는지를 잘 파악을 못했다. 알고리즘의 구동원리나 수식에 대한 부분은 어떻게든 이해를 해보려고 했고, 어떤 느낌인지는 알았으나 그래서 이 알고리즘을 가지고 어떻게 함수를 바꿔야 하는지까지는 파악하지 못했다.

4.구현한 알고리즘을 이용하여 x(t) = 3cos(20πt) + 6sin(30πt - 3/(4π)), 0 <= t <= 1 에 대한 그래프와 이 신호를 주파수 변환한 X(f)의 그래프 그리기

x(t) = 3cos(20πt) + 6sin(30πt - 3/(4π)), 0 <= t <= 1의 그래프

<img src="https://ifh.cc/g/0nanKB.png" alt="그래프 사진" style="zoom:67%;" />

주파수 f=1/T 를 이용하여 주파수를 구할 수는 있으나, 이를 푸리에 변환으로 하는 방법을 이해하지 못해서 담지 못했습니다.





